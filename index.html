[file name]: index.html
[file content begin]
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .badge {
            display: inline-block;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-shadow: 0 0 10px #FFD700;
        }

        .guide {
            color: #ccc;
            font-size: 13px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px black;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 800;
            font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
            min-width: 180px;
        }

        #btnAddPhotos {
            background: linear-gradient(to bottom, #2E7D32, #1B5E20);
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #camera-preview {
            position: fixed;
            top: 12px;
            right: 12px;
            width: 96px;
            height: 72px;
            border-radius: 10px;
            overflow: hidden;
            border: 1.5px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            transform: scaleX(-1);
            opacity: 0.65;
            z-index: 200;
            pointer-events: none;
            background: #000;
        }

        #error-log {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            color: red;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            padding: 10px;
        }

        #photo-input {
            display: none;
        }
    </style>
</head>

<body>
    <div id="error-log"></div>
    <div id="ui-layer">
        <div id="status" class="badge">üéÑ Merry Christmas üéÑ</div>
        <div class="guide">
            üñê <b>1 Tay X√≤e:</b> Bung Qu√† & ƒê√®n &nbsp;|&nbsp; üñêüñê <b>2 Tay X√≤e:</b> T·∫•t C·∫£ ·∫¢nh &nbsp;|&nbsp; üëå <b>Pinch:</b> Random ·∫¢nh &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> Thu c√¢y
            &nbsp;|&nbsp; ü§≤<b>2 Tay Cong:</b> Tr√°i Tim
        </div>
        <div class="button-container">
            <button id="btnAddPhotos" onclick="addPhotos()">‚ûï Th√™m ·∫¢nh</button>
            <button id="btnStart" onclick="startSystem()">Start</button>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
<canvas id="camera-preview"></canvas>
    
    <!-- Hidden file input for photo selection -->
    <input type="file" id="photo-input" accept="image/*" multiple>

    <script>
        // ==========================================
        // 1. RESOURCES CONFIG
        // ==========================================
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        // Default photos (can be replaced by user)
        let photoFiles = ['./img/a1.jpg', './img/a2.jpg', './img/a3.jpg', './img/a4.jpg'];
        let photoTextures = [];
        
        // Function to load textures from photoFiles array
        function loadPhotoTextures() {
            photoTextures = [];
            photoFiles.forEach((f, i) => {
                photoTextures[i] = loader.load(f, undefined, undefined, function(err) {
                    console.error('Failed to load image:', f, err);
                    // Create a placeholder texture if loading fails
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(0, 0, 256, 256);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Image', 128, 128);
                    ctx.fillText('Not Found', 128, 160);
                    photoTextures[i] = new THREE.CanvasTexture(canvas);
                });
            });
        }
        
        // Load default textures initially
        loadPhotoTextures();

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'gold_glow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.2, '#FFFFE0');
                grd.addColorStop(0.5, '#FFD700');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'red_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFAAAA');
                grd.addColorStop(0.3, '#FF0000');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'gift_red') {
                ctx.fillStyle = '#D32F2F'; 
                ctx.fillRect(20, 20, 88, 88);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(54, 20, 20, 88);
                ctx.fillRect(20, 54, 88, 20);
                ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2; ctx.strokeRect(20, 20, 88, 88);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift_red')
        };

        // ==========================================
        // 2. SYSTEM CONFIG
        // ==========================================
        const CONFIG = {
            goldCount: 2000,  
            redCount: 300,  
            giftCount: 150, 
            explodeRadius: 65,
            photoOrbitRadius: 25,
            treeHeight: 70,
            treeBaseRadius: 35,
            heartSize: 40,
            photoRotationSpeed: 0.5, // T·ªëc ƒë·ªô xoay v√≤ng c·ªßa ·∫£nh (rad/s)
            photoOrbitSpeed: 1.0,    // T·ªëc ƒë·ªô di chuy·ªÉn tr√™n qu·ªπ ƒë·∫°o
            photoBobSpeed: 2.0,      // T·ªëc ƒë·ªô l√™n xu·ªëng c·ªßa ·∫£nh
            photoBobHeight: 4.0,     // ƒê·ªô cao l√™n xu·ªëng c·ªßa ·∫£nh
            
            // C·∫•u h√¨nh cho ch·∫ø ƒë·ªô T·∫§T C·∫¢ ·∫¢NH (L∆Ø·ªöI)
            allPhotosGridCols: 3,            // S·ªë c·ªôt trong l∆∞·ªõi
            allPhotosGridSpacingX: 12,       // Kho·∫£ng c√°ch gi·ªØa c√°c ·∫£nh theo tr·ª•c X
            allPhotosGridSpacingY: 10,       // Kho·∫£ng c√°ch gi·ªØa c√°c ·∫£nh theo tr·ª•c Y
            allPhotosScale: 2.0,             // K√≠ch th∆∞·ªõc ·∫£nh NH·ªé H∆†N
            allPhotosZDistance: 40,          // Kho·∫£ng c√°ch Z t·ª´ camera
            allPhotosRotationSpeed: 0.08,    // T·ªëc ƒë·ªô xoay ch·∫≠m r√£i
            allPhotosBobSpeed: 0.5,          // T·ªëc ƒë·ªô l√™n xu·ªëng ch·∫≠m
            allPhotosBobHeight: 1.0,         // ƒê·ªô cao l√™n xu·ªëng
            
            // C·∫•u h√¨nh di chuy·ªÉn ng·∫´u nhi√™n cho T·∫§T C·∫¢ particles
            particleFloatSpeed: 0.5,     // T·ªëc ƒë·ªô di chuy·ªÉn qua l·∫°i
            particleFloatRange: 15,      // Ph·∫°m vi di chuy·ªÉn
            particleBobSpeed: 2.0,       // T·ªëc ƒë·ªô l√™n xu·ªëng
            particleBobHeight: 2.0,      // ƒê·ªô cao l√™n xu·ªëng
            particleRotationSpeed: 0.3,  // T·ªëc ƒë·ªô xoay
            particlePulseSpeed: 1.5,     // T·ªëc ƒë·ªô nh·∫•p nh√°y
            particlePulseAmount: 0.15,   // Bi√™n ƒë·ªô nh·∫•p nh√°y
            particleOpacitySpeed: 1.0,   // T·ªëc ƒë·ªô thay ƒë·ªïi opacity
            particleOpacityAmount: 0.2   // Bi√™n ƒë·ªô thay ƒë·ªïi opacity
        };

        let scene, camera, renderer;
        let groupGold, groupRed, groupGift; 
        let photoMeshes = [];
        let titleMesh, starMesh, loveTextMesh;
        let treeEffectParticles = [];
        let treeEffectTime = 0;
        let photoOrbitAngle = 0; // G√≥c qu·ªπ ƒë·∫°o hi·ªán t·∫°i c·ªßa c√°c ·∫£nh
        let photoBobOffset = 0; // Offset cho hi·ªáu ·ª©ng l√™n xu·ªëng
        let particleTime = 0; // Th·ªùi gian cho hi·ªáu ·ª©ng particles
        let allPhotosTime = 0; // Th·ªùi gian cho ch·∫ø ƒë·ªô t·∫•t c·∫£ ·∫£nh
        
        // L∆∞u tr·ªØ d·ªØ li·ªáu di chuy·ªÉn cho T·∫§T C·∫¢ particles
        let particleMoveData = {
            gold: [],
            red: [],
            gift: []
        };
        
        // L∆∞u tr·ªØ v·ªã tr√≠ m·ª•c ti√™u (explode) ban ƒë·∫ßu
        let particleBasePositions = {
            gold: [],
            red: [],
            gift: []
        };

        let state = 'TREE';
        let selectedIndex = 0;
        let handX = 0.5;
        let heartRotation = 0;
        let lastPinchTime = 0;
        const PINCH_COOLDOWN = 1000; // 1 gi√¢y cooldown gi·ªØa c√°c l·∫ßn random ·∫£nh
        
        // Tree effect variables
        let treeEffectActive = false;
        let treeEffectDuration = 0;
        const TREE_EFFECT_MAX_DURATION = 2.0; // 2 gi√¢y hi·ªáu ·ª©ng
        
        // Function to add photos from user selection
        function addPhotos() {
            document.getElementById('photo-input').click();
        }
        
        // Handle photo selection
        document.getElementById('photo-input').addEventListener('change', function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            // Clear existing photo files
            photoFiles = [];
            
            // Create object URLs for selected files
            for (let i = 0; i < files.length; i++) {
                const url = URL.createObjectURL(files[i]);
                photoFiles.push(url);
            }
            
            // Reload textures
            loadPhotoTextures();
            
            // Update photo meshes if they already exist
            if (photoMeshes.length > 0) {
                updatePhotoMeshes();
            }
            
            // Update status
            document.getElementById('status').innerText = `‚úÖ ƒê√£ th√™m ${files.length} ·∫£nh`;
            document.getElementById('status').style.color = "#00FF00";
            
            setTimeout(() => {
                document.getElementById('status').innerText = "üéÑ Giang Sinh An Lanh üéÑ";
                document.getElementById('status').style.color = "#FFF";
            }, 2000);
        });
        
        // Function to update photo meshes with new textures
        function updatePhotoMeshes() {
            // Remove old photo meshes from scene
            photoMeshes.forEach(mesh => {
                scene.remove(mesh);
            });
            
            // Clear photoMeshes array
            photoMeshes = [];
            
            // Create new photo meshes
            createPhotos();
        }
        
        // Function to randomize selected photo
        function randomizePhoto() {
            if (photoMeshes.length === 0) return;
            
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * photoMeshes.length);
            } while (newIndex === selectedIndex && photoMeshes.length > 1);
            
            selectedIndex = newIndex;
            
            // Hi·ªáu ·ª©ng chuy·ªÉn ·∫£nh
            if (state === 'PHOTO') {
                photoMeshes.forEach((mesh, i) => {
                    if (i === selectedIndex) {
                        // Hi·ªáu ·ª©ng scale up cho ·∫£nh m·ªõi
                        mesh.scale.set(0.1, 0.1, 0.1);
                    }
                });
            }
        }
        
        // Function to trigger tree effect
        function triggerTreeEffect() {
            treeEffectActive = true;
            treeEffectDuration = TREE_EFFECT_MAX_DURATION;
            treeEffectTime = 0;
            
            // T·∫°o hi·ªáu ·ª©ng particles cho c√¢y
            createTreeEffectParticles();
            
            // Ph√°t √¢m thanh hi·ªáu ·ª©ng (n·∫øu c√≥)
            playTreeEffectSound();
        }
        
        // Function to create tree effect particles
        function createTreeEffectParticles() {
            // X√≥a particles c≈© n·∫øu c√≥
            treeEffectParticles.forEach(particle => {
                scene.remove(particle);
            });
            treeEffectParticles = [];
            
            // T·∫°o c√°c particles m·ªõi
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                size: 3,
                map: textures.gold,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                
                // B·∫Øt ƒë·∫ßu t·ª´ ƒë·ªânh c√¢y (n∆°i c√≥ ng√¥i sao)
                const startX = (Math.random() - 0.5) * 10;
                const startY = CONFIG.treeHeight / 2 + 5;
                const startZ = (Math.random() - 0.5) * 10;
                
                positions[idx] = startX;
                positions[idx + 1] = startY;
                positions[idx + 2] = startZ;
                
                // T·∫°o velocity ng·∫´u nhi√™n
                velocities.push({
                    x: (Math.random() - 0.5) * 0.5,
                    y: Math.random() * 0.3 + 0.1,
                    z: (Math.random() - 0.5) * 0.5
                });
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            particles.userData = { velocities: velocities, life: 1.0 };
            scene.add(particles);
            treeEffectParticles.push(particles);
            
            // T·∫°o th√™m particles m√†u ƒë·ªè
            const redParticleMaterial = new THREE.PointsMaterial({
                size: 2.5,
                map: textures.red,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const redPositions = new Float32Array(particleCount * 3);
            const redVelocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                
                // B·∫Øt ƒë·∫ßu t·ª´ gi·ªØa c√¢y
                const startX = (Math.random() - 0.5) * 25;
                const startY = (Math.random() - 0.5) * 30;
                const startZ = (Math.random() - 0.5) * 25;
                
                redPositions[idx] = startX;
                redPositions[idx + 1] = startY;
                redPositions[idx + 2] = startZ;
                
                // T·∫°o velocity ng·∫´u nhi√™n
                redVelocities.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: Math.random() * 0.2 + 0.05,
                    z: (Math.random() - 0.5) * 0.3
                });
            }
            
            const redParticleGeometry = new THREE.BufferGeometry();
            redParticleGeometry.setAttribute('position', new THREE.BufferAttribute(redPositions, 3));
            
            const redParticles = new THREE.Points(redParticleGeometry, redParticleMaterial);
            redParticles.userData = { velocities: redVelocities, life: 1.0 };
            scene.add(redParticles);
            treeEffectParticles.push(redParticles);
        }
        
        // Function to update tree effect particles
        function updateTreeEffect(deltaTime) {
            if (!treeEffectActive) return;
            
            treeEffectDuration -= deltaTime;
            treeEffectTime += deltaTime;
            
            if (treeEffectDuration <= 0) {
                treeEffectActive = false;
                // X√≥a particles
                treeEffectParticles.forEach(particle => {
                    scene.remove(particle);
                });
                treeEffectParticles = [];
                return;
            }
            
            // C·∫≠p nh·∫≠t t·∫•t c·∫£ particles
            treeEffectParticles.forEach(particle => {
                const positions = particle.geometry.attributes.position.array;
                const velocities = particle.userData.velocities;
                const life = particle.userData.life;
                
                for (let i = 0; i < velocities.length; i++) {
                    const idx = i * 3;
                    
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ theo velocity
                    positions[idx] += velocities[i].x * deltaTime * 30;
                    positions[idx + 1] += velocities[i].y * deltaTime * 30;
                    positions[idx + 2] += velocities[i].z * deltaTime * 30;
                    
                    // Th√™m tr·ªçng l·ª±c nh·∫π
                    velocities[i].y -= 0.01 * deltaTime * 30;
                    
                    // L√†m ch·∫≠m d·∫ßn
                    velocities[i].x *= 0.98;
                    velocities[i].y *= 0.98;
                    velocities[i].z *= 0.98;
                }
                
                particle.geometry.attributes.position.needsUpdate = true;
                
                // Hi·ªáu ·ª©ng m·ªù d·∫ßn
                const fade = treeEffectDuration / TREE_EFFECT_MAX_DURATION;
                particle.material.opacity = fade * 0.8;
                
                // Hi·ªáu ·ª©ng scale nh·∫•p nh√°y
                const pulse = 1 + Math.sin(treeEffectTime * 10) * 0.2;
                particle.scale.set(pulse, pulse, pulse);
            });
            
            // Hi·ªáu ·ª©ng cho c√¢y th√¥ng ch√≠nh
            const pulseIntensity = Math.sin(treeEffectTime * 8) * 0.3 + 0.7;
            const treePulse = 1 + Math.sin(treeEffectTime * 5) * 0.1;
            
            if (groupGold) {
                groupGold.scale.set(treePulse, treePulse, treePulse);
                groupGold.material.opacity = pulseIntensity;
            }
            if (groupRed) {
                groupRed.scale.set(treePulse, treePulse, treePulse);
                groupRed.material.opacity = pulseIntensity;
            }
            if (groupGift) {
                groupGift.scale.set(treePulse, treePulse, treePulse);
                groupGift.material.opacity = pulseIntensity;
            }
            
            // Hi·ªáu ·ª©ng cho ng√¥i sao
            if (starMesh) {
                const starPulse = 1 + Math.sin(treeEffectTime * 6) * 0.3;
                starMesh.scale.set(starPulse, starPulse, starPulse);
                starMesh.rotation.z += 0.05;
            }
        }
        
        // Function to play tree effect sound
        function playTreeEffectSound() {
            try {
                const sound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ');
                sound.volume = 0.3;
                sound.play().catch(e => console.log('Sound play failed:', e));
            } catch (e) {
                console.log('Sound error:', e);
            }
        }
        
        // Function to initialize particle movement data for ALL particle groups
        function initParticleMovement() {
            // Kh·ªüi t·∫°o cho m·ªói nh√≥m particles
            const groups = [
                { type: 'gold', group: groupGold, count: CONFIG.goldCount },
                { type: 'red', group: groupRed, count: CONFIG.redCount },
                { type: 'gift', group: groupGift, count: CONFIG.giftCount }
            ];
            
            groups.forEach(({ type, group, count }) => {
                if (!group) return;
                
                particleBasePositions[type] = [];
                particleMoveData[type] = [];
                
                const explodeTargets = group.geometry.userData.explode;
                
                // L∆∞u v·ªã tr√≠ m·ª•c ti√™u (explode) ban ƒë·∫ßu cho m·ªói particle
                for (let i = 0; i < count; i++) {
                    const idx = i * 3;
                    
                    // L∆∞u v·ªã tr√≠ g·ªëc
                    particleBasePositions[type].push({
                        x: explodeTargets[idx],
                        y: explodeTargets[idx + 1],
                        z: explodeTargets[idx + 2]
                    });
                    
                    // T·∫°o d·ªØ li·ªáu di chuy·ªÉn NG·∫™U NHI√äN cho m·ªói particle
                    particleMoveData[type].push({
                        // Offsets v√† phases ng·∫´u nhi√™n
                        timeOffsetX: Math.random() * Math.PI * 2,
                        timeOffsetY: Math.random() * Math.PI * 2,
                        timeOffsetZ: Math.random() * Math.PI * 2,
                        
                        // T·ªëc ƒë·ªô ng·∫´u nhi√™n (m·ªói particle c√≥ t·ªëc ƒë·ªô ri√™ng)
                        speedX: 0.3 + Math.random() * 0.4,
                        speedY: 0.5 + Math.random() * 0.5,
                        speedZ: 0.3 + Math.random() * 0.4,
                        
                        // Bi√™n ƒë·ªô ng·∫´u nhi√™n
                        amplitudeX: 0.5 + Math.random() * 1.5,
                        amplitudeY: 0.3 + Math.random() * 1.0,
                        amplitudeZ: 0.5 + Math.random() * 1.5,
                        
                        // H∆∞·ªõng ng·∫´u nhi√™n
                        directionX: Math.random() > 0.5 ? 1 : -1,
                        directionZ: Math.random() > 0.5 ? 1 : -1,
                        
                        // T·ªëc ƒë·ªô l√™n xu·ªëng ri√™ng
                        bobSpeed: 1.0 + Math.random() * 2.0,
                        bobOffset: Math.random() * Math.PI * 2,
                        bobHeight: 0.5 + Math.random() * 1.5,
                        
                        // Hi·ªáu ·ª©ng pulse ri√™ng
                        pulseSpeed: 1.0 + Math.random() * 2.0,
                        pulseOffset: Math.random() * Math.PI * 2,
                        pulseAmount: 0.05 + Math.random() * 0.15,
                        
                        // Hi·ªáu ·ª©ng opacity ri√™ng
                        opacitySpeed: 0.5 + Math.random() * 1.5,
                        opacityOffset: Math.random() * Math.PI * 2,
                        opacityAmount: 0.1 + Math.random() * 0.2
                    });
                }
            });
        }
        
        // Function to update ALL particle movement in EXPLODE mode
        function updateAllParticleMovement(deltaTime) {
            if (state !== 'EXPLODE') return;
            
            particleTime += deltaTime;
            
            // C·∫≠p nh·∫≠t cho t·∫•t c·∫£ c√°c nh√≥m particles
            const groups = [
                { type: 'gold', group: groupGold, count: CONFIG.goldCount },
                { type: 'red', group: groupRed, count: CONFIG.redCount },
                { type: 'gift', group: groupGift, count: CONFIG.giftCount }
            ];
            
            groups.forEach(({ type, group, count }) => {
                if (!group || particleMoveData[type].length === 0) return;
                
                const positions = group.geometry.attributes.position.array;
                const basePositions = particleBasePositions[type];
                const moveDataArray = particleMoveData[type];
                
                for (let i = 0; i < count; i++) {
                    const idx = i * 3;
                    const moveData = moveDataArray[i];
                    const basePos = basePositions[i];
                    
                    // T√≠nh to√°n di chuy·ªÉn NG·∫™U NHI√äN theo c·∫£ 3 tr·ª•c
                    const moveX = Math.sin(particleTime * CONFIG.particleFloatSpeed * moveData.speedX + 
                                          moveData.timeOffsetX) * 
                                 CONFIG.particleFloatRange * moveData.amplitudeX * moveData.directionX;
                    
                    const moveZ = Math.cos(particleTime * CONFIG.particleFloatSpeed * moveData.speedZ * 1.3 + 
                                          moveData.timeOffsetZ) * 
                                 CONFIG.particleFloatRange * moveData.amplitudeZ * 0.7 * moveData.directionZ;
                    
                    // Di chuy·ªÉn l√™n xu·ªëng v·ªõi pattern ri√™ng cho m·ªói particle
                    const bobY = Math.sin(particleTime * CONFIG.particleBobSpeed * moveData.bobSpeed + 
                                         moveData.bobOffset) * 
                                CONFIG.particleBobHeight * moveData.bobHeight;
                    
                    // Th√™m chuy·ªÉn ƒë·ªông ng·∫´u nhi√™n nh·∫π theo tr·ª•c Y
                    const randomY = Math.sin(particleTime * moveData.speedY + moveData.timeOffsetY) * 
                                   moveData.amplitudeY;
                    
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ v·ªõi t·∫•t c·∫£ c√°c hi·ªáu ·ª©ng
                    positions[idx] = basePos.x + moveX;
                    positions[idx + 1] = basePos.y + bobY + randomY;
                    positions[idx + 2] = basePos.z + moveZ;
                }
                
                // C·∫≠p nh·∫≠t geometry
                group.geometry.attributes.position.needsUpdate = true;
                
                // Hi·ªáu ·ª©ng xoay t·ªïng th·ªÉ cho m·ªói nh√≥m (m·ªói nh√≥m xoay kh√°c nhau)
                if (type === 'gold') {
                    group.rotation.y += CONFIG.particleRotationSpeed * deltaTime * 0.3;
                    group.rotation.x = Math.sin(particleTime * 0.2) * 0.05;
                } else if (type === 'red') {
                    group.rotation.y -= CONFIG.particleRotationSpeed * deltaTime * 0.4;
                    group.rotation.z = Math.cos(particleTime * 0.25) * 0.03;
                } else if (type === 'gift') {
                    group.rotation.y += CONFIG.particleRotationSpeed * deltaTime * 0.5;
                    group.rotation.x = Math.sin(particleTime * 0.3) * 0.08;
                    group.rotation.z = Math.cos(particleTime * 0.2) * 0.04;
                }
                
                // Hi·ªáu ·ª©ng pulse t·ªïng th·ªÉ cho m·ªói nh√≥m
                const groupPulse = 1 + Math.sin(particleTime * CONFIG.particlePulseSpeed) * 
                                 CONFIG.particlePulseAmount;
                group.scale.set(groupPulse, groupPulse, groupPulse);
                
                // Hi·ªáu ·ª©ng opacity dao ƒë·ªông cho m·ªói nh√≥m
                const groupOpacity = 0.7 + Math.sin(particleTime * CONFIG.particleOpacitySpeed) * 
                                   CONFIG.particleOpacityAmount;
                group.material.opacity = Math.max(0.5, Math.min(1.0, groupOpacity));
            });
        }
        
        // Function to update photo orbit rotation (ch·∫ø ƒë·ªô 1 tay x√≤e)
        function updatePhotoOrbit(deltaTime) {
            if (state !== 'EXPLODE' || photoMeshes.length === 0) return;
            
            // C·∫≠p nh·∫≠t g√≥c qu·ªπ ƒë·∫°o
            photoOrbitAngle += CONFIG.photoOrbitSpeed * deltaTime;
            
            // C·∫≠p nh·∫≠t offset cho hi·ªáu ·ª©ng l√™n xu·ªëng
            photoBobOffset += CONFIG.photoBobSpeed * deltaTime;
            
            const baseAngle = photoOrbitAngle;
            const angleStep = (Math.PI * 2) / Math.max(photoMeshes.length, 1);
            let bestIdx = 0; 
            let maxZ = -999;

            photoMeshes.forEach((mesh, i) => {
                mesh.visible = true;
                
                // T√≠nh v·ªã tr√≠ tr√™n qu·ªπ ƒë·∫°o tr√≤n
                const angle = baseAngle + i * angleStep;
                const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
                const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
                
                // Th√™m hi·ªáu ·ª©ng l√™n xu·ªëng (bobbing)
                const bobY = Math.sin(photoBobOffset + i * 0.5) * CONFIG.photoBobHeight;
                
                // Di chuy·ªÉn m∆∞·ª£t ƒë·∫øn v·ªã tr√≠ m·ªõi
                mesh.position.lerp(new THREE.Vector3(x, bobY, z), 0.1);
                
                // ·∫¢nh lu√¥n h∆∞·ªõng v·ªÅ camera
                mesh.lookAt(camera.position);
                
                // Th√™m xoay nh·∫π quanh tr·ª•c c·ªßa ch√≠nh n√≥
                mesh.rotation.z += CONFIG.photoRotationSpeed * deltaTime * 0.5;
                
                // X√°c ƒë·ªãnh ·∫£nh n√†o g·∫ßn camera nh·∫•t (c√≥ Z l·ªõn nh·∫•t)
                if (z > maxZ) { 
                    maxZ = z; 
                    bestIdx = i; 
                }

                // Hi·ªáu ·ª©ng scale d·ª±a tr√™n v·ªã tr√≠
                // ·∫¢nh g·∫ßn camera h∆°n s·∫Ω l·ªõn h∆°n
                const distanceFactor = (z + CONFIG.photoOrbitRadius) / (2 * CONFIG.photoOrbitRadius);
                const targetScale = 0.6 + distanceFactor * 0.8;
                
                // Th√™m hi·ªáu ·ª©ng pulse nh·∫π ƒë·ªìng b·ªô v·ªõi particles
                const pulse = 1 + Math.sin(particleTime * 3 + i) * 0.1;
                const finalScale = targetScale * pulse;
                
                mesh.scale.lerp(new THREE.Vector3(finalScale, finalScale, finalScale), 0.1);
                
                // Hi·ªáu ·ª©ng opacity d·ª±a tr√™n v·ªã tr√≠
                const opacity = 0.7 + distanceFactor * 0.3;
                mesh.material.opacity = opacity;
                mesh.material.transparent = true;
            });
            
            selectedIndex = bestIdx;
        }
        
        // Function to update ALL PHOTOS display (ch·∫ø ƒë·ªô 2 tay x√≤e) - L∆Ø·ªöI
        function updateAllPhotos(deltaTime) {
            if (state !== 'ALL_PHOTOS' || photoMeshes.length === 0) return;
            
            allPhotosTime += deltaTime;
            
            // T√≠nh to√°n s·ªë c·ªôt t·ªëi ∆∞u d·ª±a tr√™n s·ªë l∆∞·ª£ng ·∫£nh
            // V·ªõi 1-4 ·∫£nh: 2 c·ªôt, 5-9 ·∫£nh: 3 c·ªôt, 10+ ·∫£nh: 4 c·ªôt
            let cols;
            if (photoMeshes.length <= 4) cols = 2;
            else if (photoMeshes.length <= 9) cols = 3;
            else cols = 4;
            
            const spacingX = 15; // TƒÉng kho·∫£ng c√°ch X ƒë·ªÉ kh√¥ng ƒë√® l√™n nhau
            const spacingY = 12; // TƒÉng kho·∫£ng c√°ch Y
            const totalPhotos = Math.min(photoMeshes.length, 20); // Gi·ªõi h·∫°n t·ªëi ƒëa 20 ·∫£nh
            const photoScale = Math.min(2.5, 3.0 - (totalPhotos * 0.1)); // Scale gi·∫£m d·∫ßn theo s·ªë l∆∞·ª£ng ·∫£nh
            
            // T√≠nh s·ªë h√†ng d·ª±a tr√™n s·ªë c·ªôt
            const rows = Math.ceil(totalPhotos / cols);
            
            // T√≠nh k√≠ch th∆∞·ªõc t·ªïng c·ªßa l∆∞·ªõi
            const gridWidth = (cols - 1) * spacingX;
            const gridHeight = (rows - 1) * spacingY;
            
            // ƒêi·ªÅu ch·ªânh kho·∫£ng c√°ch Z d·ª±a tr√™n s·ªë l∆∞·ª£ng ·∫£nh ƒë·ªÉ kh√¥ng qu√° g·∫ßn camera
            const zDistance = 35 + (rows * 2);
            
            photoMeshes.forEach((mesh, i) => {
                if (i >= totalPhotos) {
                    mesh.visible = false;
                    return;
                }
                
                mesh.visible = true;
                
                // T√≠nh v·ªã tr√≠ trong l∆∞·ªõi
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                // T√≠nh t·ªça ƒë·ªô X, Y trong l∆∞·ªõi (t√¢m l∆∞·ªõi ·ªü 0,0)
                const gridX = (col * spacingX) - (gridWidth / 2);
                const gridY = (row * -spacingY) + (gridHeight / 2); // -Y ƒë·ªÉ ƒëi t·ª´ tr√™n xu·ªëng
                
                // Th√™m hi·ªáu ·ª©ng l√™n xu·ªëng ch·∫≠m r√£i
                const bobY = Math.sin(allPhotosTime * 0.3 + i * 0.5) * 0.8;
                
                // V·ªã tr√≠ Z
                const targetZ = zDistance;
                
                // T√≠nh v·ªã tr√≠ target
                const targetX = gridX;
                const targetY = gridY + bobY;
                
                // Di chuy·ªÉn m∆∞·ª£t ƒë·∫øn v·ªã tr√≠ m·ªõi
                mesh.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.1);
                
                // ·∫¢nh lu√¥n h∆∞·ªõng v·ªÅ camera (nh∆∞ng c√≥ g√≥c nghi√™ng nh·∫π)
                mesh.lookAt(camera.position);
                
                // Th√™m xoay r·∫•t ch·∫≠m quanh tr·ª•c c·ªßa ch√≠nh n√≥
                mesh.rotation.z += 0.02 * deltaTime;
                
                // Scale ·∫£nh d·ª±a tr√™n s·ªë l∆∞·ª£ng
                const targetScale = photoScale;
                
                // Th√™m hi·ªáu ·ª©ng pulse nh·∫π nh√†ng
                const pulse = 1 + Math.sin(allPhotosTime * 0.8 + i * 0.3) * 0.05;
                const finalScale = targetScale * pulse;
                
                mesh.scale.lerp(new THREE.Vector3(finalScale, finalScale, finalScale), 0.1);
                
                // Opacity cao ƒë·ªÉ xem r√µ
                mesh.material.opacity = 0.95;
                mesh.material.transparent = true;
                
                // Th√™m hi·ªáu ·ª©ng glow cho border
                const border = mesh.children[0];
                if (border) {
                    const borderGlow = 1 + Math.sin(allPhotosTime * 0.5 + i * 0.7) * 0.3;
                    border.material.color.setRGB(borderGlow * 0.8, borderGlow * 0.6, 0);
                    border.scale.set(1.08, 1.08, 1);
                }
            });
        }

        // ==========================================
        // 3. THREE.JS SYSTEM
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.5); 
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0); 
            
            // Kh·ªüi t·∫°o d·ªØ li·ªáu di chuy·ªÉn cho T·∫§T C·∫¢ particles
            initParticleMovement();

            createPhotos();
            createDecorations();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pExplodeTargets = [];
            const pTreeTargets = [];
            const pHeartTargets = [];

            for (let i = 0; i < count; i++) {
                
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;

                
                let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1;

                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * radiusRatio;
                const theta = Math.random() * Math.PI * 2;

                const tx = r * Math.cos(theta);
                const tz = r * Math.sin(theta);
                pTreeTargets.push(tx, y, tz);

                
                const u = Math.random();
                const v = Math.random();
                const phi = Math.acos(2 * v - 1);
                const lam = 2 * Math.PI * u;

                
                let radMult = (type === 'gift') ? 1.2 : 1.0;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;

                const ex = rad * Math.sin(phi) * Math.cos(lam);
                const ey = rad * Math.sin(phi) * Math.sin(lam);
                const ez = rad * Math.cos(phi);
                pExplodeTargets.push(ex, ey, ez);

                // --- Heart shape ---
                const t = Math.random() * Math.PI * 2;
                const s = CONFIG.heartSize;
                let hx = s * 16 * Math.pow(Math.sin(t), 3) / 16;
                let hy = s * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;
                let hz = (Math.random() - 0.5) * 15;
                pHeartTargets.push(hx, hy, hz);

                
                pPositions.push(tx, y, tz);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.userData = { tree: pTreeTargets, explode: pExplodeTargets, heart: pHeartTargets };

            const mat = new THREE.PointsMaterial({
                size: size,
                map: textures[type],
                transparent: true, opacity: 1.0,
                
                blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            const borderGeo = new THREE.PlaneGeometry(9, 9);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });

            // Create photo meshes based on available textures
            const photoCount = Math.min(photoTextures.length, 20); // TƒÉng gi·ªõi h·∫°n l√™n 20 ·∫£nh
            
            for (let i = 0; i < photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({
                    map: photoTextures[i] || photoTextures[0], // Fallback to first texture if not available
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1;
                mesh.add(border);

                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            // ===============================
            // ‚ù§Ô∏è I LOVE YOU (INSIDE HEART)
            // ===============================
            const loveCanvas = document.createElement('canvas');
            loveCanvas.width = 1024;
            loveCanvas.height = 256;
            const lctx = loveCanvas.getContext('2d');

            lctx.clearRect(0, 0, 1024, 256);
            lctx.font = 'bold italic 120px "Times New Roman"';
            lctx.textAlign = 'center';
            lctx.fillStyle = '#FF3366';
            lctx.shadowColor = '#FF99AA';
            lctx.shadowBlur = 40;
            lctx.fillText('I LOVE YOU', 512, 160);

            const loveTex = new THREE.CanvasTexture(loveCanvas);
            const loveMat = new THREE.MeshBasicMaterial({
                map: loveTex,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            loveTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 10),
                loveMat
            );

            loveTextMesh.position.set(0, 0, 0);
            loveTextMesh.visible = false;
            scene.add(loveTextMesh);

            
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold italic 90px "Times New Roman"';
            ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
            ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 40;
            ctx.fillText("MERRY CHRISTMAS", 512, 130);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);

            
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128; starCanvas.height = 128;
            const sCtx = starCanvas.getContext('2d');
            sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor = "#FFF"; sCtx.shadowBlur = 20;
            sCtx.beginPath();
            const cx = 64, cy = 64, outer = 50, inner = 20;
            for (let i = 0; i < 5; i++) {
                sCtx.lineTo(cx + Math.cos((18 + i * 72) / 180 * Math.PI) * outer, cy - Math.sin((18 + i * 72) / 180 * Math.PI) * outer);
                sCtx.lineTo(cx + Math.cos((54 + i * 72) / 180 * Math.PI) * inner, cy - Math.sin((54 + i * 72) / 180 * Math.PI) * inner);
            }
            sCtx.closePath(); sCtx.fill();
            const starTex = new THREE.CanvasTexture(starCanvas);
            const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent: true, blending: THREE.AdditiveBlending });
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
            starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
            scene.add(starMesh);
        }

        function updateParticleGroup(group, targetState, speed, handRotY, time, isBlinking) {
            const positions = group.geometry.attributes.position.array;
            let targetKey = 'tree';
            if (targetState === 'EXPLODE') targetKey = 'explode';
            else if (targetState === 'PHOTO') targetKey = 'explode';
            else if (targetState === 'HEART') targetKey = 'heart';
            else if (targetState === 'ALL_PHOTOS') targetKey = 'explode'; // V·∫´n gi·ªØ v·ªã tr√≠ explode

            const targets = group.geometry.userData[targetKey];

            // Ch·ªâ √°p d·ª•ng chuy·ªÉn ƒë·ªông m∆∞·ª£t khi KH√îNG ·ªü ch·∫ø ƒë·ªô EXPLODE ho·∫∑c ALL_PHOTOS
            if (targetState !== 'EXPLODE' && targetState !== 'ALL_PHOTOS') {
                for (let i = 0; i < positions.length; i++) {
                    positions[i] += (targets[i] - positions[i]) * speed;
                }
            }
            
            group.geometry.attributes.position.needsUpdate = true;

            
            if (targetState === 'TREE') {
                // Tr·ª´ khi ƒëang c√≥ hi·ªáu ·ª©ng, c√¢y quay b√¨nh th∆∞·ªùng
                if (!treeEffectActive) {
                    group.rotation.y += 0.003;
                }
                
                if (isBlinking && !treeEffectActive) {
                    const scale = 1 + Math.sin(time * 5) * 0.2;
                    group.scale.set(scale, scale, scale);
                } else if (!treeEffectActive) {
                    group.scale.set(1, 1, 1);
                }
                
                // Reset hi·ªáu ·ª©ng khi v·ªÅ ch·∫ø ƒë·ªô TREE
                group.rotation.x = 0;
                group.rotation.z = 0;
                group.material.opacity = 1.0;
            } else if (targetState === 'HEART') {
                group.scale.set(1, 1, 1);
                group.rotation.y = heartRotation;
                group.rotation.x = 0;
                group.rotation.z = 0;
            } else if (targetState === 'EXPLODE' || targetState === 'ALL_PHOTOS') {
                // ·ªû ch·∫ø ƒë·ªô EXPLODE ho·∫∑c ALL_PHOTOS, t·∫•t c·∫£ hi·ªáu ·ª©ng ƒë∆∞·ª£c x·ª≠ l√Ω ri√™ng
                // Kh√¥ng c·∫ßn l√†m g√¨ th√™m ·ªü ƒë√¢y
            } else {
                group.scale.set(1, 1, 1);
                group.rotation.y += (handRotY - group.rotation.y) * 0.05;
                group.rotation.x = 0;
                group.rotation.z = 0;
            }
            
            // Reset opacity n·∫øu kh√¥ng c√≥ hi·ªáu ·ª©ng
            if (!treeEffectActive && group.material.opacity !== 1.0) {
                if (state !== 'EXPLODE' && state !== 'ALL_PHOTOS') {
                    group.material.opacity = 1.0;
                }
            }
        }

        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            // T√≠nh deltaTime
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            const time = Date.now() * 0.001;
            const speed = 0.06;
            const handRotY = (handX - 0.5) * 2.5;

            
            updateParticleGroup(groupGold, state, speed, handRotY, time, false);
            updateParticleGroup(groupRed, state, speed, handRotY, time, false); 
            updateParticleGroup(groupGift, state, speed, handRotY, time, false);
            
            // C·∫≠p nh·∫≠t hi·ªáu ·ª©ng c√¢y n·∫øu ƒëang active
            updateTreeEffect(deltaTime);
            
            // C·∫≠p nh·∫≠t di chuy·ªÉn NG·∫™U NHI√äN cho T·∫§T C·∫¢ particles n·∫øu ·ªü ch·∫ø ƒë·ªô EXPLODE
            if (state === 'EXPLODE') {
                updateAllParticleMovement(deltaTime);
            }
            
            // C·∫≠p nh·∫≠t xoay v√≤ng ·∫£nh n·∫øu ·ªü ch·∫ø ƒë·ªô EXPLODE (1 tay x√≤e)
            if (state === 'EXPLODE') {
                updatePhotoOrbit(deltaTime);
            }
            
            // C·∫≠p nh·∫≠t T·∫§T C·∫¢ ·∫£nh n·∫øu ·ªü ch·∫ø ƒë·ªô ALL_PHOTOS (2 tay x√≤e)
            if (state === 'ALL_PHOTOS') {
                updateAllPhotos(deltaTime);
            }

            // Quay tr√°i tim
            if (state === 'HEART') {
                heartRotation += 0.01;
                // ‚ù§Ô∏è Hi·ªán ch·ªØ I LOVE YOU trong tim
                loveTextMesh.visible = true;

                // Nh·ªãp ƒë·∫≠p nh·∫π
                const pulse = 1 + Math.sin(time * 3) * 0.05;
                loveTextMesh.scale.set(pulse, pulse, 1);

                // Gi·ªØ ch·ªØ lu√¥n quay v·ªÅ camera
                loveTextMesh.lookAt(camera.position);
            }

            
            photoMeshes.forEach((mesh, i) => {
                if (!mesh.material.map && photoTextures[i]) {
                    mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
                }
            });

            if (state === 'TREE') {
                if (loveTextMesh) loveTextMesh.visible = false;

                titleMesh.visible = true; 
                starMesh.visible = true;
                titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                
                // Ng√¥i sao quay n·∫øu kh√¥ng c√≥ hi·ªáu ·ª©ng
                if (!treeEffectActive) {
                    starMesh.rotation.z -= 0.02;
                    starMesh.scale.set(1, 1, 1);
                }
                
                photoMeshes.forEach(m => { 
                    m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); 
                    m.visible = false;
                    m.material.opacity = 1.0;
                });

            } else if (state === 'HEART') {
                titleMesh.visible = false; starMesh.visible = false;
                photoMeshes.forEach(m => { 
                    m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); 
                    m.visible = false;
                    m.material.opacity = 1.0;
                });

            } else if (state === 'EXPLODE') {
                titleMesh.visible = false; starMesh.visible = false;
                // Hi·ªáu ·ª©ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong updateAllParticleMovement() v√† updatePhotoOrbit()

            } else if (state === 'ALL_PHOTOS') {
                titleMesh.visible = false; starMesh.visible = false;
                // Hi·ªáu ·ª©ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong updateAllPhotos()

            } else if (state === 'PHOTO') {
                photoMeshes.forEach((mesh, i) => {
                    if (i === selectedIndex) {
                        // Hi·ªáu ·ª©ng ph√≥ng to v√† di chuy·ªÉn v√†o gi·ªØa
                        mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
                        mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
                        mesh.lookAt(camera.position);
                        mesh.rotation.z = 0;
                        
                        // Th√™m hi·ªáu ·ª©ng xoay nh·∫π
                        mesh.rotation.y += 0.01;
                        
                        // Reset opacity
                        mesh.material.opacity = 1.0;
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    }
                });
            }

            renderer.render(scene, camera);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            document.getElementById('btnAddPhotos').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('status');

            let frameCnt = 0;
            let isPinching = false; // Theo d√µi tr·∫°ng th√°i pinch
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                ctx.clearRect(0, 0, 100, 75); ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                // Ki·ªÉm tra 2 tay l√†m tr√°i tim (∆∞u ti√™n cao nh·∫•t)
                if (results.multiHandLandmarks.length === 2) {
                    const hand1 = results.multiHandLandmarks[0];
                    const hand2 = results.multiHandLandmarks[1];

                    // L·∫•y ƒë·∫ßu ng√≥n c√°i v√† ng√≥n tr·ªè c·ªßa 2 tay
                    const thumb1 = hand1[4];
                    const index1 = hand1[8];
                    const thumb2 = hand2[4];
                    const index2 = hand2[8];

                    // T√≠nh kho·∫£ng c√°ch gi·ªØa c√°c ng√≥n
                    const thumbDist = Math.hypot(thumb1.x - thumb2.x, thumb1.y - thumb2.y);
                    const indexDist = Math.hypot(index1.x - index2.x, index1.y - index2.y);

                    // Ki·ªÉm tra v·ªã tr√≠ t·∫°o th√†nh h√¨nh tr√°i tim
                    const avgY1 = (thumb1.y + index1.y) / 2;
                    const avgY2 = (thumb2.y + index2.y) / 2;
                    const thumbsClose = thumbDist < 0.08;
                    const indexesApart = indexDist > 0.15;
                    const sameHeight = Math.abs(avgY1 - avgY2) < 0.1;

                    if (thumbsClose && indexesApart && sameHeight) {
                        state = 'HEART';
                        statusDiv.innerText = "ü§≤ 2 Tay Gh√©p Tr√°i Tim";
                        statusDiv.style.color = "#FF69B4";
                        return;
                    }
                }

                // Ki·ªÉm tra 2 tay x√≤e (ch·∫ø ƒë·ªô T·∫§T C·∫¢ ·∫¢NH)
                if (results.multiHandLandmarks.length === 2) {
                    let bothHandsOpen = true;
                    
                    // Ki·ªÉm tra c·∫£ 2 tay ƒë·ªÅu x√≤e ra
                    for (let handIdx = 0; handIdx < 2; handIdx++) {
                        const lm = results.multiHandLandmarks[handIdx];
                        
                        const tips = [8, 12, 16, 20]; // ƒê·∫ßu ng√≥n tr·ªè, gi·ªØa, √°p √∫t, √∫t
                        const wrist = lm[0];
                        let openDist = 0;
                        
                        tips.forEach(i => {
                            const tip = lm[i];
                            openDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                        });
                        const avgDist = openDist / 4;
                        
                        // NG∆Ø·ª¢C L·∫†I: N·∫øu tay X√íE ra (avgDist L·ªöN) th√¨ m·ªõi l√† x√≤e
                        // Tay n·∫Øm l·∫°i s·∫Ω c√≥ avgDist nh·ªè
                        if (avgDist < 0.3) { // Ng∆∞·ª°ng TH·∫§P H∆†N ƒë·ªÉ d·ªÖ k√≠ch ho·∫°t
                            bothHandsOpen = false;
                            break;
                        }
                    }
                    
                    if (bothHandsOpen) {
                        state = 'ALL_PHOTOS';
                        statusDiv.innerText = "üñêüñê T·∫•t C·∫£ ·∫¢nh (L∆∞·ªõi)";
                        statusDiv.style.color = "#FF33CC";
                        return;
                    }
                }

                // Ki·ªÉm tra 1 tay x√≤e (ch·∫ø ƒë·ªô EXPLODE) ho·∫∑c c√°c c·ª≠ ch·ªâ kh√°c
                if (results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x;

                    const tips = [8, 12, 16, 20];
                    const wrist = lm[0];
                    let openDist = 0;
                    tips.forEach(i => openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
                    const avgDist = openDist / 4;
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                    if (avgDist < 0.25) {
                        state = 'TREE';
                        statusDiv.innerText = "‚úä Thu C√¢y Th√¥ng"; statusDiv.style.color = "#FFD700";
                        isPinching = false;
                    } else if (pinchDist < 0.05) {
                        // Ki·ªÉm tra cooldown ƒë·ªÉ tr√°nh random qu√° nhanh
                        const now = Date.now();
                        if (!isPinching && now - lastPinchTime > PINCH_COOLDOWN) {
                            // Chuy·ªÉn sang ch·∫ø ƒë·ªô xem ·∫£nh v√† random ·∫£nh m·ªõi
                            state = 'PHOTO';
                            randomizePhoto();
                            lastPinchTime = now;
                            
                            // K√≠ch ho·∫°t hi·ªáu ·ª©ng cho c√¢y th√¥ng
                            triggerTreeEffect();
                            
                            statusDiv.innerText = "üëå Random ·∫¢nh + Hi·ªáu ·ª®ng C√¢y"; 
                            statusDiv.style.color = "#00FFFF";
                            
                            // Hi·ªáu ·ª©ng th√¥ng b√°o
                            setTimeout(() => {
                                if (state === 'PHOTO') {
                                    statusDiv.innerText = "üëå Xem ·∫¢nh"; 
                                    statusDiv.style.color = "#00FFFF";
                                }
                            }, 1000);
                        } else {
                            state = 'PHOTO';
                            statusDiv.innerText = "üëå Xem ·∫¢nh"; 
                            statusDiv.style.color = "#00FFFF";
                        }
                        isPinching = true;
                    } else {
                        // ƒê√¢y l√† 1 TAY X√íE (ch·∫ø ƒë·ªô EXPLODE)
                        state = 'EXPLODE';
                        statusDiv.innerText = "üñê 1 Tay X√≤e: Qu√† & ƒê√®n Bay"; 
                        statusDiv.style.color = "#FFA500";
                        isPinching = false;
                    }
                } else {
                    state = 'TREE';
                    statusDiv.innerText = "üéÑ Giang Sinh An Lanh üéÑ"; 
                    statusDiv.style.color = "#FFF";
                    isPinching = false;
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    frameCnt++; if (frameCnt % 3 !== 0) return;
                    await hands.send({ image: video });
                }, width: 320, height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if (camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        });
        function logError(e) { document.getElementById('error-log').style.display = 'block'; document.getElementById('error-log').innerText += e + "\n"; }
    </script>
</body>

</html>
[file content end]
